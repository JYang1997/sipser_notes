# Random notes about language
### 1.
	There are three different terms,
	1. language
	2. language generator (grammar of the language)
	3. language recognizer (machine (automaton))
1. **language** are represent in the form of expressions (regular expression, context-free expression)
2. **grammar** specified rules for generating the language.
3. **automaton** is a machine that recognize the language.

### 2.
Pumping lemma is useful for proving a language is not CFL or RL.

Basic Idea:
1. If the language size is **finite**, then it is obvious. (RL)
2. If the language size is not **finite**, then by pigeonhole, there must be part of the rule reused.
3. This reuse of rule lead to loop in the path, then remove such loop, or repeat multiple times should not affect acceptance of the string.


# Chapter 1 Regular Language
> **Definition**
> A **finite automaton** is a 5-tuple $(Q, \Sigma , \delta, q_0 F)$, where
> 1. Q is a finite set called the **states**.
> 2.  $\Sigma$ is a finite set called the **alphabets**.
> 3. $\delta : Q \times \Sigma \rightarrow Q$ is the transition function.
> 4. $q_0 \in Q$ is the start state
> 5. $F \subseteq Q$ is the set of  accept states.
>
> A **nondeterministic finite automaton** allow $\epsilon$ transition, that is,
> 3. $\delta : Q \times \Sigma_\epsilon \rightarrow Q$ is the transition function.

> **Theorem**
> Every nondeterministic finite automaton has an equivalent deterministic finite automaton.
 

Finite automaton is the recognizers for equivalent **Regular Languages**. Another words, Regular Languages are exactly the languages accepted by (non)deterministic finite automata;


> **Definition**
>  Formal definition for **Regular Expression** if R is 
>  1. $a$ for some $a$ in the alphabet $\Sigma$,
>  2. $\epsilon$
> 3. $\empty$
> 4. $(R_1 \cup R_2 )$, where $R_1$ and $R_2$ are regular expressions,
> 5. (R 1 ◦ R 2 ), where $R_1$ and $R_2$ are regular expressions, or
> 6. $(R_1^* )$, where $R_1$ is a regular expression.
In items 1 and 2, the regular expressions a and ε represent the
languages {a} and {ε}, respectively. In item 3, the regular expres-
sion ∅ represents the empty language. In items 4, 5, and 6, the
expressions represent the languages obtained by taking the union
or concatenation of the languages R 1 and R 2 , or the star of the
language R 1 , respectively.
 
 ### Differentiating Non-Regular Languages 
To differentiating  regularities, we can use **Pumping lemma**

> **Pumping Lemma**
>   If $A$ id a regular language, then there is a number $p$ (the pumping length) where if $s$ is any string in $A$ of length at least $p$, then $s$ may be divided into three pieces, $s = xyz$, satisfying the following conditions:
>   >1. for each $i \geq 0$, $xy^iz \in A$,
>   >2. $|y| > 0$, and
>   >3. $|xy| \leq p$.

The proof is really trivial (based on pigeonhole principle).

The pumping lemma is useful when you try to prove a language is not regular.
But this theorem is not really useful if you try to prove a language **is** regular.
The pumping lemma is a one way statement, says nothing about non-regular language.
Showing second part is not sufficient for proving the language is regular.

To prove a language is regular, one can start from the definition, or its equivalent models.

#### Strategies for using pumping lemma.
1.  Start with proof by contradiction.
2.  Choose a particular string, with length $\geq p$. (choose a string that break the rule when pump).
3.  Then use the fact that $|xy| \leq p$, to help you break the pumpable property
4.  Last, show for which choice of $i$ in $xy^iz$ where such property break.

> **Example**
> Show that $AB1 = \{a^ib^j : i \geq j\}$ is not regular.
> >***note***: we want to break the property where $i \geq j$  
> 1. A assume $AB1$ is regular.
> 2. Let $\omega = "a^nb^n"$ //setting a, b length equal to each other still in the language. then we break it by pump away a to make first part smaller.
> 3. Then by definition $xy = a^m$, where $m \leq n$ must be true.
> 4. let $i = 0$, contradiction. QED
#### Second approach for proving non-regular: use the definition, show that the language is not closed under Concatenation, Union or Kleene star. 

# Chapter 2 Context Free Language
	 
### TODO:
	1. show inherently ambiguous
	2. if language is generatable, can you always built equivalent machine recognize it?.
	3. complete example when review for exam
>**Definition**
> CFG is 4-tuple $(V, \Sigma, R, S)$
> 1. V is a finite set called variables
> 2. $\Sigma$ is a finite set called terminals (disjoint from V).
> 3. R is a finite set of rules
> 4. $S \in V$ is a start varible.

>**Definition**
> A **context free laguage** is any language that is generated by a context-free grammar. (CFL)



>**Definition**
>A string $\omega$ is derived **ambiguously** in context-free grammar G if it has two or more different **leftmost derivations**. Grammar G is ambiguous if it generates some string ambiguously.
> 
> ***leftmost derivation**:  if at every step the leftmost remaining variable is the one replaced.

>**Theorem**
> Any CFL is generated by a CFG in Chomsky normal form


> **Definition**
>  A **pushdown automaton** is a 6-tuple $(Q, \Sigma, \Gamma , \delta, q_0, F)$, where $Q, \Sigma, \Gamma$, and $F$ are all finite sets, and
>  > 1. $Q$ is set of states
>  > 2. $\Sigma$ is the input alphabet,
>  > 3. $\Gamma$ is the stack alphabet,
>  > 4.  $\delta : Q \times \Sigma_\epsilon \times \Gamma_\epsilon \rightarrow P(Q \times \Gamma_\epsilon)$ is the transition function.
>  > 5. $q_0 \in Q$ is the start state.
>  > 6. $F \subseteq Q$ is the set accept states.


> **Theorem 2.20**
> A language is context free if and only if some pushdown automaton recognizes it.

The proof for above theorem is redious, basically it's a proof by construction, where it shows that start from one of it you can construct the other one.


### Differentiating Non-Context-Free Languages

> **Pumping Lemma for Context-Free Languages**
> If $A$ is context-free language, then there is a number $p$ (the pumping length) where, if $s$ is any in $A$ of length at least $p$, then $s$ may be divided into five pieces  $s = uvxyz$ satisfying the conditions,
> >1. for each $i \geq 0$, $uv^ixy^iz \in A$
>> 2. $|uy| > 0$
>>3. $|vxy| \leq p$.

The **pumping length** has upper bound $b^{|V|+1}$, where $|V|$ is the number of variables in the grammar, and b is the maximum number of symbols in the right hand side of a rule. 
This pumping length implies that the strings greater than such length must have parse tree at least
$|V|+1$ high, because $b^{|V|+1} \geq b^{|V|}+1$.
Which immediately follow that there must be loop in the derivation.

>**Example**


# Chapter 3 The Church-Turing Thesis

>**Definition**
> A **Turing machine** is a 7-tuple, $(Q, Σ, Γ, δ, q_0 , q_{accept} , q_{reject} )$, where
$Q, Σ, Γ$ are all finite sets and
> 1. $Q$ is the set of states,
> 2. $Σ$ is the input alphabet not containing the blank symbol ␣ ,
> 3. $Γ$ is the tape alphabet, where $␣ ∈ Γ$ and $Σ ⊆ Γ$,
> 4. $δ : Q × Γ \rightarrow Q × Γ × \{L, R\}$ is the transition function,
> 5. $q_0 ∈ Q$ is the start state,
> 6. $q_{accept} ∈ Q$ is the accept state, and
> 7. $q_{reject} ∈ Q$ is the reject state, where $q_{reject} \neq q_{accept}$

> Written with [StackEdit](https://stackedit.io/).

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExNTM4NzU4NjgsNTY0Mjg1MjE1XX0=
-->